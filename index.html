<!doctype html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>کارگاه امضای امن — تولید و بررسی (Ed25519 + AES-256-GCM)</title>
<style>
  /* Classic parchment background + clean card UI */
  body{font-family: Tahoma, 'Segoe UI', Roboto, Arial; background: radial-gradient(circle at 10% 10%, #fffef8, #f4ecd6 30%, #e6d7a3 60%); color:#111; margin:0; padding:28px;}
  .container{max-width:900px;margin:0 auto}
  header{text-align:center;margin-bottom:18px}
  h1{margin:0;font-size:22px}
  .card{background:rgba(255,255,255,0.85);border:1px solid rgba(0,0,0,0.06);padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(20,20,40,0.08);margin-bottom:12px}
  label{display:block;margin-top:10px;font-weight:600}
  textarea,input,select,button{width:100%;padding:10px;margin-top:8px;border-radius:8px;border:1px solid #d3caa0;background:transparent}
  .row{display:flex;gap:8px}
  .col{flex:1}
  button.primary{background:#3b6b2f;color:#fff;border:0;padding:10px;border-radius:8px;cursor:pointer}
  pre{background:#fff8e6;padding:10px;border-radius:8px;overflow:auto;white-space:pre-wrap}
  .artifact{display:flex;gap:8px;align-items:flex-start;margin-top:8px}
  .actions{display:flex;flex-direction:column;gap:6px}
  .muted{color:#5b4b2d;font-size:13px}
  .small{font-size:13px;color:#4a3d2a}
  .inline{display:inline-block}
  footer{margin-top:18px;text-align:center;color:#4a3d2a}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>کارگاه امضای امن — تولید و بررسی</h1>
    <div class="small">الگوریتم امضا: Ed25519  — رمزگذاری امضا: AES-256-GCM (مشتق‌شده از پس‌عبور)</div>
  </header>  <div class="card">
    <label>پیغام یا متن برای امضا</label>
    <textarea id="message" rows="4">این یک پیام نمونه است.</textarea><label>پس‌عبور برای رمزگذاری AES-256 (رمز عبور را به‌خاطر بسپار)</label>
<input id="passphrase" type="password" placeholder="یک پس‌عبور قوی وارد کنید" />

<div class="row">
  <div class="col"><button id="gen" class="primary">تولید کلید و امضا + رمزگذاری</button></div>
  <div class="col"><button id="verify" class="primary" style="background:#6b4c2f">بررسی امضا (Decrypt + Verify)</button></div>
</div>

<div style="margin-top:12px">
  <label>خروجی‌ها</label>
  <div id="artifacts">
    <div class="small muted">بعد از «تولید» خروجی‌ها اینجا نمایش داده می‌شوند.</div>
  </div>
</div>

  </div>  <div class="card">
    <h3>راهنمای سریع</h3>
    <ul class="muted">
      <li>کلید خصوصی در مرورگر ساخته می‌شود و به‌صورت پیش‌فرض نمایش داده نمی‌شود — در صورت نیاز می‌توان آن را دانلود کرد.</li>
      <li>پس‌عبور را برای رمزگشایی امضا حفظ کن — بدون پس‌عبور کسی نمی‌تواند امضای رمزشده را باز کند.</li>
      <li>برای بررسی: کاربر باید کلید عمومی، امضای رمزشده (JSON) و پس‌عبور را وارد کند.</li>
    </ul>
  </div>  <footer class="small">نسخهٔ کلاینت — هیچ داده‌ای به سرور ارسال نمی‌شود مگر کاربر خودش اقدام کند.</footer>
</div><script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script><script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script><script>
// Helper utilities
const u8ToB64 = (u8) => btoa(String.fromCharCode(...u8));
const b64ToU8 = (b64) => new Uint8Array(atob(b64).split('').map(c=>c.charCodeAt(0)));
const u8ToHex = (u8) => Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('');

// Web Crypto helpers for AES-256-GCM + PBKDF2
async function deriveKeyFromPassphrase(passphrase, salt, iterations=150000){
  const enc = new TextEncoder();
  const passKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2', salt: salt, iterations: iterations, hash: 'SHA-256'}, passKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
}

async function aesGcmEncrypt(key, plaintext){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder();
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv: iv}, key, enc.encode(plaintext));
  return { iv: u8ToB64(iv), ct: u8ToB64(new Uint8Array(ct)) };
}

async function aesGcmDecrypt(key, iv_b64, ct_b64){
  const iv = b64ToU8(iv_b64);
  const ct = b64ToU8(ct_b64);
  const dec = await crypto.subtle.decrypt({name:'AES-GCM', iv: iv}, key, ct);
  return new TextDecoder().decode(dec);
}

// Main UI logic
const $ = id => document.getElementById(id);
const artifactsEl = $('artifacts');

function showArtifacts(list){
  artifactsEl.innerHTML = '';
  for(const it of list){
    const wrap = document.createElement('div');
    wrap.className = 'artifact card';
    wrap.style.padding='10px';
    const left = document.createElement('div');
    left.style.flex='1';
    const title = document.createElement('div');
    title.innerHTML = '<strong>' + it.name + '</strong> <div class="small">' + (it.note||'') + '</div>';
    const pre = document.createElement('pre');
    pre.textContent = it.value;
    left.appendChild(title);
    left.appendChild(pre);

    const actions = document.createElement('div');
    actions.className = 'actions';
    const btnCopy = document.createElement('button'); btnCopy.className='btn-ghost'; btnCopy.textContent='کپی';
    btnCopy.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(it.value); alert('کپی شد ✅'); }catch(e){ alert('کپی موفق نبود: '+e); } });
    const btnDl = document.createElement('button'); btnDl.className='btn-ghost'; btnDl.textContent='دانلود';
    btnDl.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href = URL.createObjectURL(new Blob([it.value],{type:'text/plain'})); a.download = (it.filename|| (it.name.replace(/\s+/g,'_')+'.txt')); a.click(); });
    actions.appendChild(btnCopy); actions.appendChild(btnDl);

    wrap.appendChild(left); wrap.appendChild(actions);
    artifactsEl.appendChild(wrap);
  }
}

// Generate: create Ed25519 keypair, sign message, derive AES key from passphrase, encrypt signature (base64), output public key + encrypted bundle
$('gen').addEventListener('click', async ()=>{
  try{
    const message = $('message').value || '';
    const pass = $('passphrase').value;
    if(!pass){ alert('لطفاً یک پس‌عبور وارد کنید تا امضا رمزنگاری شود.'); return; }

    // 1. generate Ed25519 keypair (tweetnacl)
    const kp = nacl.sign.keyPair();
    const pub_b64 = u8ToB64(kp.publicKey);
    const priv_seed_b64 = u8ToB64(kp.secretKey.slice(0,32)); // seed (optional)

    // 2. sign message
    const msgU8 = nacl.util.decodeUTF8(message);
    const signature = nacl.sign.detached(msgU8, kp.secretKey); // Uint8Array
    const sig_b64 = u8ToB64(signature);

    // 3. derive AES-256 key from passphrase using PBKDF2 with random salt
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const derivedKey = await deriveKeyFromPassphrase(pass, salt, 150000);

    // 4. encrypt signature (we'll encrypt the base64 signature string)
    const encRes = await aesGcmEncrypt(derivedKey, sig_b64);

    // 5. prepare a JSON bundle that contains salt, iv, ciphertext and algorithm metadata
    const bundle = {
      alg: 'AES-256-GCM',
      kdf: 'PBKDF2-SHA256',
      kdf_iter: 150000,
      salt: u8ToB64(salt),
      iv: encRes.iv,
      ciphertext: encRes.ct,
      enc_data: 'signature_base64'
    };

    // show outputs
    showArtifacts([
      {name:'Public Key (base64)', value: pub_b64, filename:'public_key.b64.txt', note:'برای بررسی امضا منتشر کنید.'},
      {name:'Encrypted Signature (JSON)', value: JSON.stringify(bundle, null, 2), filename:'signature_encrypted.json', note:'برای بررسی نیاز به پس‌عبور و کلید عمومی دارید.'},
      {name:'Private Key Seed (base64) — نگهداری امن', value: priv_seed_b64, filename:'private_seed.b64.txt', note:'کلید خصوصی (seed). اگر می‌خواهید کلید را بازسازی کنید از این استفاده کنید.'},
      {name:'Plain Signature (base64) — فقط محلی', value: sig_b64, filename:'signature.b64.txt', note:'امضای اصلی (فقط برای ذخیره محلی)'}
    ]);

    alert('امضا ایجاد و رمزگذاری شد ✅\nکلید عمومی و بستهٔ رمزشده آماده است.');
  }catch(e){ console.error(e); alert('خطا: '+e); }
});

// Verify: user provides public key (base64), encrypted JSON bundle, and passphrase. We'll derive key, decrypt signature, and verify signature against message.
$('verify').addEventListener('click', async ()=>{
  try{
    const pub_b64 = prompt('کلید عمومی را (base64) وارد یا paste کن:');
    if(!pub_b64) return;
    const bundle_text = prompt('بستهٔ رمزشده (JSON) را وارد یا paste کن:');
    if(!bundle_text) return;
    const pass = prompt('پس‌عبور برای رمزگشایی وارد کن:');
    if(!pass) return;

    let bundle;
    try{ bundle = JSON.parse(bundle_text); } catch(e){ alert('بستهٔ JSON معتبر نیست.'); return; }
    if(!bundle.salt || !bundle.iv || !bundle.ciphertext){ alert('بسته ناقص است. باید salt، iv و ciphertext داشته باشد.'); return; }

    // derive key
    const salt = b64ToU8(bundle.salt);
    const derivedKey = await deriveKeyFromPassphrase(pass, salt, bundle.kdf_iter || 150000);

    // decrypt
    let sig_b64;
    try{
      sig_b64 = await aesGcmDecrypt(derivedKey, bundle.iv, bundle.ciphertext);
    }catch(e){ alert('رمزگشایی موفق نبود — پس‌عبور اشتباه یا داده خراب است.'); return; }

    // verify signature
    const message = $('message').value || '';
    const msgU8 = nacl.util.decodeUTF8(message);
    const sigU8 = b64ToU8(sig_b64);
    const pubU8 = b64ToU8(pub_b64);
    const ok = nacl.sign.detached.verify(msgU8, sigU8, pubU8);
    if(ok){ alert('امضا معتبر است ✅'); }
    else { alert('امضا نامعتبر ❌ — یا پیام/کلید عمومی/امضا با هم مطابقت ندارند.'); }
  }catch(e){ console.error(e); alert('خطا: '+e); }
});
</script></body>
</html>
